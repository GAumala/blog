<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Android,Fragment,navigation,Bundle,FragmentTransaction,back stack">
    <meta name="description" content="Navigating through multiple fragments in an Android application" />
    <meta name="twitter:card" content="summary">
    <meta name="twitter:description" content="Navigating through multiple fragments in an Android application">
    <meta property="og:locale" content="es_US">
    <meta property="og:title" content="Navigating with fragments">
    <meta property="og:description" content="Navigating through multiple fragments in an Android application">
    <title>Navigating with fragments</title>
    <link rel="stylesheet" href="../css/post-bundle.css" />
  </head>
  <body>
    <header>
      <nav>
        <a href="../" title="Home">
          <img id="home" src="../assets/images/home.svg" alt="Home"></a>
        <a href="../rss/posts.rss" title="RSS feed">
          <img class="icon-rss" src="../assets/images/rss.svg" alt="RSS"></a>
        <a href="https://twitter.com/gaumala987" title="Twitter profile">
          <img class="icon" src="../assets/images/twitter.svg" alt="Twitter"></a>
        <a href="https://github.com/GAumala" title="GitHub profile">
          <img class="icon" src="../assets/images/github.svg" alt="GitHub"></a>
      </nav>
    </header>

    <h1 class="post-title">Navigating with fragments</h1>
    <div class="date"><span>May  3, 2020</span></div>
    <article>
      <section>
        <p>Navigating between different “places” of your app, is probably one of the most complicated things in Android. There are many APIs that you can use depending on what components you are using (activities or fragments), and how do you want to pass data (if any?) between them. Unfortunately, I don’t think there’s a silver bullet for this, so I’ll just write about the method that I like to use the most.</p>
<!--more-->
<p>First of all, I think navigation is easier if you have a single activity with multiple fragments. In fact, <a href="https://www.reddit.com/r/androiddev/comments/8i73ic/its_official_google_officially_recommends_single/?user_id=172167102077">Google recommends using single-Activity apps</a>. I know that there have been plenty of issues with fragments over the years, but these days with AndroidX libraries, they work great. Hopefully <a href="https://www.youtube.com/watch?v=RS1IACnZLy4">they will get only better</a>. This doesn’t mean that you are restricted to having only one activity. There are valid cases for launching a new activity, but it’s better to minimize those.</p>
<p>The only problem that I still have with fragments is the back stack. It’s nice to have an easy way to return to previous fragments, but the fragment back stack API is very limited and clumsy. Sure, you can go back to the last fragment with <code>popBackStack()</code>, but if you want to go back to an arbitrary earlier fragment, or clear the whole stack, it’s not very helpful. This is why I prefer to implement this stack myself and have full control over it. Going back to any previous fragment is easier if the current fragment holds the data necessary to recreate any of those fragments.</p>
<p>A good place to store this data is the fragment’s arguments. When you create a fragment, you can use <code>setArguments()</code> to pass data to it inside a <code>Bundle</code>. This is important because the OS will persist this data so it doesn’t get lost when the fragment gets destroyed for whatever reason. This isn’t unique to fragments. It also happens to activities and extra data passed to them via <code>Intent</code>. If you pass your back stack data via arguments, it will never get lost.</p>
<p>Consider a scenario in which there is a <code>MyListFragment</code> and when users click one of the items in the list they navigate to <code>MyDetailFragment</code> so that they can see more data about the selected item and maybe do some editing. If they do edit it, then when they go back to the first fragment, the update should be instantly reflected on the list.</p>
<p>Here’s how I would implement this. The code for going into <code>MyDetailFragment</code> would be something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">val</span> <span class="va">listState</span> = captureListState()</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">val</span> <span class="va">bundle</span> = Bundle()</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">bundle.putParcelable(<span class="st">&quot;myListState&quot;</span>, captureListState())</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">val</span> <span class="va">newFragment</span> = MyDetailFragment()</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">newFragment.arguments = bundle</a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">fragmentManager.beginTransaction()</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    .setCustomAnimations(</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">        R.anim.enter_from_right,</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">        R.anim.exit_to_left,</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">        R.anim.enter_from_left,</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">        R.anim.exit_to_right)</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">    .replace(R.id.container, newFragment)</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">    .commit()</a></code></pre></div>
<p>The function <code>captureListState()</code> returns a <code>Parcelable</code> object that <code>MyDetailFragment</code> can retrieve from its arguments and use to reconstruct the list. Implementing <code>Parcelable</code> manually is error prone so I prefer to have some tool do it for me. I usually go with <a href="https://android.jlelse.eu/yet-another-awesome-kotlin-feature-parcelize-5439718ba220">data classes annotated with <code>@Parcelize</code></a>, or <a href="https://github.com/rharter/auto-value-parcel">AutoValue</a> if I have to do this in Java.</p>
<p>When <code>MyDetailFragment</code> is created, it should retrieve <code>listState</code> from arguments and keep it somewhere convenient like a view model so that it can be updated if the user edits the data. Then, an <code>OnBackPresedCallback</code> should be added to reconstruct <code>MyListFragment</code> when the user presses back.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">private</span> <span class="kw">val</span> <span class="va">onBackPressedCallback</span> = <span class="kw">object</span>: <span class="dt">OnBackPressedCallback</span>(<span class="va">true</span>) {</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">handleOnBackPressed</span>() {</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">        <span class="kw">val</span> <span class="va">bundle</span> = Bundle()</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">        bundle.putParcelable(<span class="st">&quot;savedListState&quot;</span>, getUpdatedListState())</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">        <span class="kw">val</span> <span class="va">newFragment</span> = MyListFragment()</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">        newFragment.arguments = bundle</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">        fragmentManager.beginTransaction()</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">            .setCustomAnimations(</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">                R.anim.enter_from_left,</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">                R.anim.exit_to_right,</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">                R.anim.enter_from_right,</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">                R.anim.exit_to_left)</a>
<a class="sourceLine" id="cb2-15" data-line-number="15">            .replace(R.id.container, newFragment)</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">            .commit()</a>
<a class="sourceLine" id="cb2-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb2-18" data-line-number="18">}</a></code></pre></div>
<p>Once again I replace the current fragment. There are no fragments to “pop” here. When the user presses back, a new instance of <code>MyListFragment</code> is created with the updated list state. Since there’s no back stack collecting previous fragments, I am free to choose where to navigate, not just back to <code>MyListFragment</code>. Under certain conditions I may want to go back to somewhere else like <code>HomeFragment</code> and completely forget about <code>MyListFragment</code>. With this approach, is super easy to choose a new destination in <code>handleOnBackPressed()</code>.</p>
<p>Notice that the animations used here are the “opposite” of the previous transaction. This gives the illusion of going back to the original fragment. End users will never realize that it’s actually a new fragment with the same state. Rather than modifying existing fragments in a back stack, I create a new “copy” of that fragment with updated data. I personally like this <em>functional</em> approach to managing fragments, but it is not perfect. Here are some potential issues:</p>
<h3 id="scaling-to-larger-stacks">Scaling to larger stacks</h3>
<p>This example works really nice because there’s only one fragment the user can go back to. In fact you can get the same result for free by calling <code>addToBackStack()</code> in the transaction. But what if there were four, five, or an unbounded number? You’d have to add a value to the bundle for each of them. This isn’t a common thing, most apps have only so many fragments in the back stack. But, if you are struggling with this, then it’s better to use something like a queue in the arguments bundle that you pop each time user presses back. It might be a little more work, but it pays off. If you implement the most appropriate data structure for your use case, managing your fragment history is a breeze.</p>
<h3 id="coupling-fragments">Coupling fragments</h3>
<p>For a fragment to recreate its previous fragment, it has to know about it. This means that these two are <strong>coupled</strong>. Coupling is generally a bad thing in programming, and this is no exception. Fragments are meant to be reusable. If it only works if it follows a particular fragment, then it’s not very reusable.</p>
<p>For example, if I have a <code>ChangePasswordFragment</code> I will certainly navigate to it from <code>SettingsFragment</code> so that users can change passwords at any time. Additionally, I may want to navigate to it from <code>LoginFragment</code> after an user clicks “Forgot my password” and proves to be the legitimate account owner. This fragment must be reused in both cases, but they must return to completely different places once the task is complete.</p>
<p>I shouldn’t have to modify <code>ChangePasswordFragment</code> every time I want to reuse it. It’s better if the fragment itself knows nothing about the fragment(s) that came before it. A solution for this would be to declare an abstract method in <code>ChangePasswordFragment</code> that gets called when the user should navigate away from it. It would be something like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb3-1" data-line-number="1">abstract <span class="kw">class</span> PasswordChangeFragment: <span class="dt">Fragment</span>() {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    abstract <span class="kw">fun</span> <span class="fu">onQuit</span>()</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    // <span class="fu">actual</span> <span class="fu">change</span> <span class="fu">password</span> <span class="fu">UI</span> &amp; <span class="fu">logic</span> <span class="fu">here</span>. </a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    // <span class="fu">When</span> <span class="fu">the</span> <span class="fu">user</span> <span class="fu">presses</span> <span class="fu">back</span> <span class="fu">or</span> <span class="fu">sets</span> <span class="fu">a</span> <span class="fu">new</span> <span class="fu">password</span>, </a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    // <span class="fu">onQuit</span>() <span class="fu">gets</span> <span class="fu">called</span>.</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">} </a></code></pre></div>
<p>Then, <code>PasswordChangeSettingsFragment</code> and <code>PasswordChangeLoginFragment</code> extend it, recreating a different fragment in the <code>onQuit()</code> method. I’m personally not a big fan of inheritance, but this seems like an appropriate case to use it.</p>
<h3 id="complex-views">Complex views</h3>
<p>For some views, it may be too difficult to capture its current state and recreate it in a new fragment. This may be even impossible for some custom views that only expose a limited API. Ideally all views should be simple and easy to reproduce, but sometimes it can’t be helped.</p>
<p>I once tried to restore a <code>SearchView</code> inside a <code>Toolbar</code> after displaying search results in a new fragment. In the end, I decided that it was far easier to just leave it alone and display search results in a secondary activity.</p>
<h3 id="large-amounts-of-data">Large amounts of data</h3>
<p>Passing data in arguments is really convenient for persistence, but it is not meant to handle large amounts of data. Bear in mind that space for persisted data is limited and serialization should run as fast as possible. Arguments should only hold the minimum amount of data for the fragment to be able to work.</p>
<p>If a list fragment displays hundreds of thousands of items, it’s probably not a good idea to put them all in a <code>Bundle</code>. If the data is loaded from a server, the it might be better to just reload it when the user returns to ensure they always see the most up-to-date data. If you are confident about the data not changing too often then you should cache it so that reloading is instant.</p>
<h3 id="animations">Animations</h3>
<p>There are a few very solid APIs for animating fragment transitions, but you may face issues. A quick Stack Overflow search shows hundreds of questions for fragment animations. The new <a href="https://proandroiddev.com/android-fragments-fragmentcontainerview-292f393f9ccf"><code>FragmentContainerView</code> addresses one of these bugs</a>, so make sure you are using it.</p>
<p>Even after fixing all bugs, not every animation may be possible with fragments. For instance, the only Android device I currently own runs Android Pie. I really like the default animation used for activities in this version. Unfortunately, that animation can’t be recreated with fragments by simply copying the source, as it uses a <a href="https://stackoverflow.com/questions/54221728/why-i-cant-use-cliprect-in-android-anim-resource-just-like-activity-open-ente"><code>cliprect</code> tag, which is a private component</a>. I have no idea why they do this.</p>
<p>This means that if I want to use that particular transition, I have to launch a new activity. There’s no other way around it. And it goes without saying that newer versions of Android may replace it with something completely different, so its not reliable.</p>
<hr />
<p>There may be other shortcomings that I’ve missed here, but I’ve had great results with this method. I use it 90% of the time. In very few cases, I find it easier to just launch a new activity with <code>startActivityForResult()</code>. I think it’s super important to use the best tool for the job instead of rooting for a one size fits all solution.</p>
<p>I’m also keeping an eye on new APIs like the <a href="https://developer.android.com/guide/navigation">Navigation component</a>. I’ll be happy to adopt them once they become more stable, and prove to be objectively better, but for now I’m good with this.</p>
      </section>
    </article>

    <div class="footer-separator"></div>
    <div id="like-footer"></div>
    <script src="../js/post.js"></script>
  </body>
</html>
